package edu.caltech.nanodb.plans;


import edu.caltech.nanodb.expressions.OrderByExpression;
import edu.caltech.nanodb.expressions.TupleComparator;
import edu.caltech.nanodb.expressions.TupleLiteral;
import edu.caltech.nanodb.qeval.Cost;
import edu.caltech.nanodb.relations.Tuple;

import java.io.IOException;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;


/**
 */
public class SortNode extends PlanNode {


    private List<OrderByExpression> orderByExprs;


    private ArrayList<Tuple> sortedResults;

    private TupleComparator comparator;

    private int currentTupleIndex;

    private boolean done;
    

    /**
     * Constructs a PlanNode with a given operation type.  This method will be
     * called by subclass constructors.
     *
     * @param orderByExprs a specification of how the results should be ordered
     */
    public SortNode(PlanNode leftChild, List<OrderByExpression> orderByExprs) {
        super(PlanNode.OperationType.SORT, leftChild);

        if (orderByExprs == null)
            throw new IllegalArgumentException("orderByExprs cannot be null");

        if (orderByExprs.isEmpty()) {
            throw new IllegalArgumentException(
                "orderByExprs must include at least one expression");
        }

        this.orderByExprs = orderByExprs;
    }


    public List<OrderByExpression> resultsOrderedBy() {
        return orderByExprs;
    }


    /** The sort plan-node doesn't support marking. */
    public boolean supportsMarking() {
        return false;
    }


    /**
     * The sort plan-node doesn't require marking from either of its children.
     */
    public boolean requiresLeftMarking() {
        return false;
    }


    /**
     * The sort plan-node doesn't require marking from either of its children.
     */
    public boolean requiresRightMarking() {
        return false;
    }


    /**
     * Does any initialization the node might need.  This could include
     * resetting state variables or starting the node over from the beginning.
     *
     */
    public void initialize() {
        super.initialize();

        sortedResults = null;
        done = false;

        leftChild.initialize();
    }


    /**
     * Gets the next tuple that fulfills the conditions for this plan node.
     * If the node has a child, it should call getNextTuple() on the child.
     * If the node is a leaf, the tuple comes from some external source such
     * as a table file, the network, etc.
     *
     * @return the next tuple to be generated by this plan, or <tt>null</tt>
     *         if the plan has finished generating plan nodes.
     *
     * @throws java.io.IOException if table data cannot be read from the filesystem
     * @throws IllegalStateException if a plan node is not properly initialized
     */
    public Tuple getNextTuple() throws IllegalStateException, IOException {
        if (done)
            return null;

        if (sortedResults == null)
            prepareSortedResults();

        Tuple tup = null;
        if (currentTupleIndex < sortedResults.size()) {
            tup = sortedResults.get(currentTupleIndex);
            currentTupleIndex++;
        }
        else {
            done = true;
        }

        return tup;
    }


    private void prepareSortedResults() throws IOException {
        sortedResults = new ArrayList<Tuple>();
        while (true) {
            // Get the next tuple.  If it's not cacheable then make a copy of it
            // before storing it away.

            Tuple tup = leftChild.getNextTuple();
            if (tup == null)
                break;

            if (!tup.isCacheable())
                tup = new TupleLiteral(tup);

            sortedResults.add(tup);
        }

        Collections.sort(sortedResults, comparator);

        currentTupleIndex = 0;
    }


    /**
     * Computes the cost of this plan node's operation.  The computation will
     * depend on which algorithm the node uses and the data it is working with.
     *
     * @return an object containing various cost measures such as the worst-case
     *         number of disk accesses, the number of tuples produced, etc.
     */
    public Cost estimateCost() {
        return new Cost(0, 0, 0);
    }


    /**
     * The sort plan-node produces the same schema as its child plan-node, so
     * this method simply caches the subplan's schema object.
     */
    protected void prepareSchema() {
        schema = leftChild.getSchema();

        // We can prepare the tuple-comparator here too, since we know what the
        // subplan's schema will be.
        comparator = new TupleComparator(schema, orderByExprs);
    }


    /**
     * Marks the current tuple in the tuple-stream produced by this node.  The
     * {@link #resetToLastMark} method can be used to return to this tuple.
     * Note that only one marker can be set in the tuple-stream at a time.
     *
     * @throws java.lang.UnsupportedOperationException if the node does not
     *         support marking.
     *
     * @throws java.lang.IllegalStateException if there is no "current tuple" to
     *         mark.  This will occur if {@link #getNextTuple} hasn't yet been
     *         called (i.e. we are before the first tuple in the tuple-stream),
     *         or if we have already reached the end of the tuple-stream (i.e.
     *         we are after the last tuple in the stream).
     */
    public void markCurrentPosition() {
        throw new UnsupportedOperationException(
            "Sort plan-node doesn't support marking.");
    }


    /**
     * Resets the node's tuple-stream to the most recently marked position.
     * Note that only one marker can be set in the tuple-stream at a time.
     *
     * @throws java.lang.UnsupportedOperationException if the node does not
     *         support marking.
     *
     * @throws java.lang.IllegalStateException if {@link #markCurrentPosition}
     *         hasn't yet been called on this plan-node
     */
    public void resetToLastMark() {
        throw new UnsupportedOperationException(
            "Sort plan-node doesn't support marking.");
    }


    /** Clean up after evaluation of the sort plan-node. */
    public void cleanUp() {
        // TODO

        leftChild.cleanUp();
    }


    @Override
    public String toString() {
        return "Sort[" + orderByExprs + "]";
    }


    /**
     * Checks if the argument is a plan node tree with the same structure,
     * but not necesarily the same references.
     *
     * @param obj the object to which we are comparing
     *
     * @design We re-declare this here to force its implementation in subclasses.
     */
    @Override
    public boolean equals(Object obj) {
        if (obj instanceof SortNode) {
            SortNode other = (SortNode) obj;

            return orderByExprs.equals(other.orderByExprs) &&
                   leftChild.equals(other.leftChild);
        }
        return false;
    }


    /**
     * Computes the hash-code of a plan-node, including any sub-plans of this
     * plan.  This method is used to see if two plan nodes (or subtrees)
     * <em>might be</em> equal.
     *
     * @return the hash code for the plan node and any subnodes it may contain.
     */
    @Override
    public int hashCode() {
        int hash = 17;
        hash = 31 * hash + orderByExprs.hashCode();
        hash = 31 * hash + leftChild.hashCode();
        return hash;
    }
}
